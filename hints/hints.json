{
  "issue_1": {
    "titulo": "Arregla los print statements",
    "hint_1": {
      "text": "ğŸ¤” En Python 3, print es una funciÃ³n. Â¿QuÃ© necesitan las funciones para ser llamadas?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Las funciones necesitan parÃ©ntesis. TambiÃ©n, los strings necesitan comillas. Ejemplo: print('Hola')",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura correcta:\nprint('Texto aquÃ­')\nprint('Tu granja tiene', variable, 'cultivos')\nprint(f'DÃ­a: {dia}')",
      "unlock_after_minutes": 20
    }
  },
  "issue_2": {
    "titulo": "Define tipos de datos correctos",
    "hint_1": {
      "text": "ğŸ¤” Â¿CuÃ¡l es la diferencia entre '3' y 3? Â¿Entre 'True' y True?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Con comillas es string ('3'), sin comillas es nÃºmero (3). Los booleanos son True/False sin comillas.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Tipos correctos:\ntiempo_crecimiento = 3  # int\nprecio = 15.50  # float\nnecesita_agua = True  # bool",
      "unlock_after_minutes": 20
    }
  },
  "issue_3": {
    "titulo": "ConversiÃ³n de tipos",
    "hint_1": {
      "text": "ğŸ¤” No puedes multiplicar strings. Â¿CÃ³mo conviertes '10' a nÃºmero?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa int() para enteros, float() para decimales. Ejemplo: int('5') devuelve 5",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Para calcular:\nprecio_num = float(precio_texto)\ncantidad_num = int(cantidad_texto)\ntotal = precio_num * cantidad_num",
      "unlock_after_minutes": 20
    }
  },
  "issue_4": {
    "titulo": "Variables de la granja",
    "hint_1": {
      "text": "ğŸ¤” Â¿QuÃ© informaciÃ³n necesita trackear una granja? Piensa en un juego de farming.",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Una granja necesita: tamaÃ±o, agua, energÃ­a, dÃ­a actual. Se definen en __init__ con self.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ En __init__ aÃ±ade:\nself.tamaÃ±o = 10\nself.nivel_agua = 100\nself.energia = 100\nself.dia = 1",
      "unlock_after_minutes": 20
    }
  },
  "issue_5": {
    "titulo": "Input del usuario",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo puede el programa recibir informaciÃ³n del usuario?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ La funciÃ³n input() muestra un mensaje y espera que el usuario escriba algo.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Ejemplo:\nnombre = input('Â¿CÃ³mo se llama tu granja? ')\nopcion = input('Elige una opciÃ³n: ')",
      "unlock_after_minutes": 20
    }
  },
  "issue_6": {
    "titulo": "Formateo de strings",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo puedes incluir variables dentro de strings de forma dinÃ¡mica?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Los f-strings son la forma moderna: f'Hola {nombre}'. TambiÃ©n puedes usar .format() o %.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Ejemplo completo:\nf'ğŸŒ¾ GRANJA: {granja.nombre}'\nf'ğŸ’§ AGUA: {granja.nivel_agua}/100'\nf'âš¡ ENERGÃA: {granja.energia}%'",
      "unlock_after_minutes": 20
    }
  },
  "issue_7": {
    "titulo": "Operaciones aritmÃ©ticas bÃ¡sicas",
    "hint_1": {
      "text": "ğŸ¤” Â¿CuÃ¡les son las operaciones matemÃ¡ticas bÃ¡sicas? +, -, *, /, %, //...",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Para porcentajes: (parte/total) * 100. Para actualizar: variable += valor o variable -= valor.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Ejemplos:\ncosto = cantidad * precio_unitario\neficiencia = (cosechados / plantados) * 100\ngranja.agua -= agua_usada",
      "unlock_after_minutes": 20
    }
  },
  "issue_8": {
    "titulo": "Comentarios y documentaciÃ³n",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo puedes explicar tu cÃ³digo para que otros (y tÃº mismo) lo entiendan?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa # para comentarios de lÃ­nea y \"\"\" \"\"\" para docstrings de funciones. Explica QUÃ‰ hace, no cÃ³mo.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura de docstring:\ndef funcion(param):\n    \"\"\"\n    DescripciÃ³n de quÃ© hace.\n    Args: param (tipo): descripciÃ³n\n    Returns: tipo: descripciÃ³n\n    \"\"\"",
      "unlock_after_minutes": 20
    }
  },
  "issue_9": {
    "titulo": "Sistema de riego con condicionales",
    "hint_1": {
      "text": "ğŸ¤” Antes de regar, Â¿quÃ© dos cosas necesitas verificar? Piensa en la vida real.",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Necesitas: 1) Tener agua disponible (nivel_agua > 0) Y 2) El cultivo necesita agua. Usa 'and' para verificar ambas.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura:\nif self.nivel_agua > 0:\n    for cultivo in self.cultivos:\n        if cultivo.necesita_agua:\n            cultivo.regar()\n            self.nivel_agua -= 1",
      "unlock_after_minutes": 20
    }
  },
  "issue_10": {
    "titulo": "Lista de cultivos",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo almacenas mÃºltiples elementos del mismo tipo en Python?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Las listas se crean con corchetes []. Puedes iniciar vacÃ­a [] o con elementos ['tomate', 'maÃ­z']",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Cambia:\nself.cultivos = None\nPor:\nself.cultivos = []\n\nLuego usa append() para aÃ±adir.",
      "unlock_after_minutes": 20
    }
  },
  "issue_11": {
    "titulo": "MÃ©todos de lista",
    "hint_1": {
      "text": "ğŸ¤” Â¿QuÃ© operaciones puedes hacer con una lista? AÃ±adir, quitar, ordenar...",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ MÃ©todos Ãºtiles: append(item), remove(item), sort(), len(lista), item in lista",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Ejemplos:\nself.cultivos.append(nuevo_cultivo)\nself.cultivos.remove(cultivo)\nself.cultivos.sort(key=lambda x: x.precio)",
      "unlock_after_minutes": 20
    }
  },
  "issue_16": {
    "titulo": "Bucle de cosecha",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo revisas cada elemento de una lista uno por uno?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa 'for cultivo in self.cultivos:' para iterar sobre cada cultivo.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura:\ncosechados = 0\nfor cultivo in self.granja.cultivos:\n    if cultivo.puede_cosechar():\n        # cosechar\n        cosechados += 1\nreturn cosechados",
      "unlock_after_minutes": 20
    }
  },
  "issue_12": {
    "titulo": "ValidaciÃ³n de entrada con if/else",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo verificas si un nÃºmero es vÃ¡lido antes de usarlo? Â¿Y si la entrada no es un nÃºmero?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa try/except para nÃºmeros invÃ¡lidos e if para verificar rangos. Ejemplo: if cantidad <= 0:",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura de validaciÃ³n:\ntry:\n    num = int(input('NÃºmero: '))\n    if num > 0:\n        return num\n    else:\n        print('Debe ser positivo')\nexcept ValueError:\n    print('Debe ser un nÃºmero')",
      "unlock_after_minutes": 20
    }
  },
  "issue_13": {
    "titulo": "Sistema de temporadas",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo puedes verificar si un cultivo es apropiado para una temporada especÃ­fica?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Cada cultivo puede tener una lista de temporadas vÃ¡lidas. Usa 'in' para verificar: if temporada in cultivo.temporadas",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ ImplementaciÃ³n:\nif cultivo.temporadas == 'todo-temporada':\n    return True\nelif self.temporada in cultivo.temporadas:\n    return True\nelse:\n    return False",
      "unlock_after_minutes": 20
    }
  },
  "issue_14": {
    "titulo": "ComparaciÃ³n de cultivos",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo comparas dos nÃºmeros? Â¿CÃ³mo calculas rentabilidad precio/tiempo?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa operadores >, <, >= para comparar. Rentabilidad = precio / tiempo_crecimiento",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ FunciÃ³n de comparaciÃ³n:\ndef comparar_por_rentabilidad(cultivo1, cultivo2):\n    rent1 = cultivo1.precio / cultivo1.tiempo_crecimiento\n    rent2 = cultivo2.precio / cultivo2.tiempo_crecimiento\n    return cultivo1 if rent1 > rent2 else cultivo2",
      "unlock_after_minutes": 20
    }
  },
  "issue_15": {
    "titulo": "Estado del juego con booleanos",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo representas estados de verdadero/falso? Â¿CÃ³mo combinas mÃºltiples condiciones?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa variables booleanas: es_dia = True. Combina con 'and': if es_dia and not hay_tormenta:",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ VerificaciÃ³n de estado:\ndef puede_plantar(self):\n    if not self.es_dia:\n        return False, 'Solo puedes plantar de dÃ­a'\n    if self.hay_tormenta:\n        return False, 'No puedes plantar durante tormenta'\n    return True, 'OK'",
      "unlock_after_minutes": 20
    }
  },
  "issue_17": {
    "titulo": "Game loop con while",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo haces que algo se repita hasta que el usuario decida parar?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Un bucle while con una condiciÃ³n. Cambia la condiciÃ³n cuando el usuario elija salir.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura:\njugando = True\nwhile jugando:\n    mostrar_menu()\n    opcion = input('Elige: ')\n    if opcion == '0':\n        jugando = False",
      "unlock_after_minutes": 20
    }
  },
  "issue_18": {
    "titulo": "FunciÃ³n plantar_cultivo",
    "hint_1": {
      "text": "ğŸ¤” Una funciÃ³n necesita recibir parÃ¡metros y hacer algo con ellos. Â¿QuÃ© necesitas para plantar?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ La funciÃ³n debe recibir tipo_cultivo y posicion. Verifica recursos antes de plantar.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura:\ndef plantar_cultivo(self, tipo_cultivo, posicion):\n    if self.energia < 10:\n        return False\n    # crear cultivo\n    self.cultivos.append(cultivo)\n    return True",
      "unlock_after_minutes": 20
    }
  },
  "issue_19": {
    "titulo": "FunciÃ³n pasar_dia",
    "hint_1": {
      "text": "ğŸ¤” Â¿QuÃ© cosas pasan automÃ¡ticamente cada dÃ­a en una granja? Piensa en un ciclo diario.",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Incrementa self.dia, resetea energia, actualiza cada cultivo con un bucle for.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Pasos:\nself.dia += 1\nself.energia = 100\nfor cultivo in self.cultivos:\n    cultivo.crecer_un_dia()\n# crear y retornar resumen",
      "unlock_after_minutes": 20
    }
  },
  "issue_20": {
    "titulo": "Bucles anidados para regar zona",
    "hint_1": {
      "text": "ğŸ¤” Para regar un Ã¡rea rectangular, necesitas ir fila por fila y columna por columna. Â¿CÃ³mo?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Un bucle for dentro de otro: el exterior para filas (y), el interior para columnas (x).",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura:\nfor y in range(y_inicio, y_fin + 1):\n    for x in range(x_inicio, x_fin + 1):\n        cultivo = self.get_cultivo_en(x, y)\n        if cultivo: cultivo.regar()",
      "unlock_after_minutes": 20
    }
  },
  "issue_21": {
    "titulo": "FunciÃ³n con parÃ¡metros y retorno",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo calculas rentabilidad? (ganancia - costo) / tiempo. Â¿QuÃ© parÃ¡metros necesitas?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ La funciÃ³n necesita precio, tiempo_crecimiento, costo_mantenimiento=1.0. Retorna un diccionario.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Estructura:\ndef calcular_rentabilidad(precio, tiempo, costo=1.0):\n    ganancia_neta = precio - (costo * tiempo)\n    return {'ganancia_diaria': ganancia_neta/tiempo, 'clasificacion': '...'} ",
      "unlock_after_minutes": 20
    }
  },
  "issue_22": {
    "titulo": "Range y enumerate en bucles",
    "hint_1": {
      "text": "ğŸ¤” range(start, stop, step) genera nÃºmeros. enumerate(lista) da Ã­ndice y valor. Â¿CuÃ¡ndo usar cada uno?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa range() para secuencias numÃ©ricas y patrones. Usa enumerate() cuando necesitas la posiciÃ³n en la lista.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Ejemplos:\n# PatrÃ³n: for i in range(0, 20, 3)\n# Con Ã­ndices: for i, cultivo in enumerate(cultivos)\n# Intervalos: if i % intervalo == 0",
      "unlock_after_minutes": 20
    }
  },
  "issue_23": {
    "titulo": "Diccionario de cultivos",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo almacenas informaciÃ³n estructurada sobre mÃºltiples cultivos? Piensa en una base de datos simple.",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Los diccionarios pueden contener otros diccionarios. Estructura: CULTIVOS_DB = {'tomate': {'precio': 25, 'tiempo': 4}}",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Para cada cultivo incluye: precio, tiempo_crecimiento, temporadas, agua_requerida, experiencia, categoria, descripcion, nivel_requerido",
      "unlock_after_minutes": 20
    }
  },
  "issue_24": {
    "titulo": "Algoritmo de mejor cultivo",
    "hint_1": {
      "text": "ğŸ¤” Â¿QuÃ© hace a un cultivo 'mejor'? Rentabilidad, rapidez, experiencia... Â¿CÃ³mo calculas cada criterio?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Rentabilidad = precio/tiempo. Para criterio equilibrado, combina varios factores con pesos diferentes.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ FunciÃ³n estructura: def encontrar_mejor_cultivo(criterio, temporada):\n# Filtrar por temporada\n# Calcular score segÃºn criterio\n# Retornar el de mayor score",
      "unlock_after_minutes": 20
    }
  },
  "issue_25": {
    "titulo": "Sistema de batalla de cultivos",
    "hint_1": {
      "text": "ğŸ¤” Â¿QuÃ© estadÃ­sticas necesita un cultivo para 'batallar'? Ataque, defensa, salud, velocidad...",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Batalla por turnos: orden por velocidad, daÃ±o = max(1, ataque - defensa), habilidades especiales por tipo.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Clase BatallaCultivos necesita: inicializar cultivos, bucle de batalla, aplicar daÃ±o, verificar ganador, log de acciones.",
      "unlock_after_minutes": 20
    }
  },
  "issue_26": {
    "titulo": "ComprensiÃ³n de listas",
    "hint_1": {
      "text": "ğŸ¤” [expresion for item in lista if condicion] - Â¿CÃ³mo puedes filtrar y transformar listas en una sola lÃ­nea?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Para cultivos listos: [c for c in cultivos if c.esta_listo()]. Para nombres: [c.nombre for c in cultivos]",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Anidadas: [[c1 for c1 in cultivos if c1.categoria == c2.categoria] for c2 in cultivos]. Con dict: {c.nombre: c.precio for c in cultivos}",
      "unlock_after_minutes": 20
    }
  },
  "issue_27": {
    "titulo": "Diccionarios anidados",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo organizas informaciÃ³n jerÃ¡rquica? configuracion -> recursos -> agua -> actual = 100",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Acceso profundo: datos['regiones']['norte']['clima']. Para navegar dinÃ¡micamente, divide la ruta por puntos.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ FunciÃ³n obtener_valor_anidado: divide ruta, usa bucle for para navegar nivel por nivel, maneja KeyError con default.",
      "unlock_after_minutes": 20
    }
  },
  "issue_28": {
    "titulo": "Algoritmo de bÃºsqueda",
    "hint_1": {
      "text": "ğŸ¤” BÃºsqueda lineal O(n) vs binaria O(log n). Â¿CuÃ¡ndo usar cada una? Â¿QuÃ© requisitos tiene bÃºsqueda binaria?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ BÃºsqueda binaria requiere lista ordenada. BFS usa queue para vecinos, DFS usa stack. Pathfinding considera obstÃ¡culos.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Binaria: izq=0, der=len-1, medio=(izq+der)//2, compara y ajusta lÃ­mites. BFS: queue=[inicio], while queue: pos=pop(0)",
      "unlock_after_minutes": 20
    }
  },
  "issue_29": {
    "titulo": "Ordenamiento personalizado",
    "hint_1": {
      "text": "ğŸ¤” Bubble O(nÂ²), Quick O(n log n), Merge O(n log n). Â¿CuÃ¡l es mÃ¡s estable? Â¿CuÃ¡l usa menos memoria?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Merge sort es estable y divide en mitades. Quick sort pivote y particiÃ³n. Para mÃºltiples criterios: sort(key=lambda x: (criterio1, criterio2))",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Merge: if len<=1 return, divide en mitades, merge recursivo. Quick: pivote, particionar, recursivo en sublistas.",
      "unlock_after_minutes": 20
    }
  },
  "issue_30": {
    "titulo": "CÃ¡lculo de estadÃ­sticas",
    "hint_1": {
      "text": "ğŸ¤” Media = sum/n, mediana = valor medio, desviaciÃ³n = sqrt(sum((x-media)Â²)/n). Â¿CÃ³mo calculas correlaciÃ³n?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ ROI = (ganancia-inversiÃ³n)/inversiÃ³n*100. CorrelaciÃ³n Pearson: cov(x,y)/(std(x)*std(y)). Tendencia = pendiente de regresiÃ³n lineal.",
      "unlock_after_minutes": 10
    },
    "hint_3": {
      "text": "ğŸ“ Para tendencia: suma de (x*y) vs suma(x)*suma(y). Para insights: compara valores con promedios, detecta anomalÃ­as, sugiere acciones.",
      "unlock_after_minutes": 20
    }
  },
  "issue_31": {
    "titulo": "Parser de datos CSV",
    "hint_1": {
      "text": "ğŸ¤” Â¿CÃ³mo lees archivos CSV en Python? El mÃ³dulo 'csv' tiene funciones Ãºtiles como csv.reader() y csv.DictReader().",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ csv.DictReader() convierte cada fila en diccionario usando encabezados. Para fechas usa datetime.strptime(). Maneja errores con try/except.",
      "unlock_after_minutes": 15
    },
    "hint_3": {
      "text": "ğŸ“ Estructura bÃ¡sica:\nwith open(archivo, 'r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        fecha = datetime.strptime(row['fecha'], '%Y-%m-%d')\n        precio = float(row['precio'])",
      "unlock_after_minutes": 30
    }
  },
  "issue_32": {
    "titulo": "Clases y POO - Crear clase Farmer",
    "hint_1": {
      "text": "ğŸ¤” Una clase es como un molde para crear objetos. Â¿QuÃ© atributos necesita un granjero? Â¿QuÃ© mÃ©todos puede hacer?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa __init__ para constructor, @property para getters/setters, super() para herencia. Los atributos privados empiezan con _.",
      "unlock_after_minutes": 15
    },
    "hint_3": {
      "text": "ğŸ“ Estructura de clase:\nclass Farmer:\n    def __init__(self, name, experience=0):\n        self._name = name\n        self._experience = experience\n    \n    @property\n    def level(self):\n        return self._experience // 100",
      "unlock_after_minutes": 30
    }
  },
  "issue_33": {
    "titulo": "Manejo de excepciones",
    "hint_1": {
      "text": "ğŸ¤” Â¿QuÃ© puede salir mal en una granja? Falta de recursos, mal clima, errores de archivo... Cada error necesita manejo especÃ­fico.",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Crea excepciones personalizadas heredando de Exception. Usa try/except/finally. El bloque finally siempre se ejecuta.",
      "unlock_after_minutes": 15
    },
    "hint_3": {
      "text": "ğŸ“ ExcepciÃ³n personalizada:\nclass InsufficientResourcesError(Exception):\n    def __init__(self, resource, needed, available):\n        super().__init__(f'Falta {resource}: necesitas {needed}, tienes {available}')",
      "unlock_after_minutes": 30
    }
  },
  "issue_34": {
    "titulo": "Decoradores y funciones avanzadas",
    "hint_1": {
      "text": "ğŸ¤” Los decoradores 'envuelven' funciones para aÃ±adir funcionalidad. Â¿CÃ³mo medirÃ­as tiempo o validarÃ­as permisos automÃ¡ticamente?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Un decorador bÃ¡sico: def mi_decorador(func): def wrapper(*args, **kwargs): return func(*args, **kwargs); return wrapper. Usa @functools.wraps(func).",
      "unlock_after_minutes": 15
    },
    "hint_3": {
      "text": "ğŸ“ Decorador con parÃ¡metros:\ndef timing(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f'{func.__name__}: {time.time() - start:.2f}s')\n        return result\n    return wrapper",
      "unlock_after_minutes": 30
    }
  },
  "issue_35": {
    "titulo": "Sistema de persistencia con JSON",
    "hint_1": {
      "text": "ğŸ¤” JSON puede almacenar diccionarios, listas, strings, nÃºmeros, booleanos. Â¿CÃ³mo guardas objetos complejos como fechas o clases personalizadas?",
      "unlock_after_minutes": 0
    },
    "hint_2": {
      "text": "ğŸ’¡ Usa json.dumps() para serializar, json.loads() para deserializar. Para objetos complejos, crea un JSONEncoder personalizado.",
      "unlock_after_minutes": 15
    },
    "hint_3": {
      "text": "ğŸ“ Encoder personalizado:\nclass FarmJSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        if hasattr(obj, '__dict__'):\n            return obj.__dict__\n        return super().default(obj)",
      "unlock_after_minutes": 30
    }
  }
}